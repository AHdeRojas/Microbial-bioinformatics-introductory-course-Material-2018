[
["introduction.html", "OPEN &amp; REPRODUCIBLE MICROBIOME DATA ANALYSIS SPRING SCHOOL 2018 1 Introduction 1.1 Preparing for the course 1.2 Useful functions 1.3 Focus 1.4 Target audience 1.5 License", " OPEN &amp; REPRODUCIBLE MICROBIOME DATA ANALYSIS SPRING SCHOOL 2018 Sudarshan A. Shetty, Leo Lahti, Gerben DA. Hermes 2018-05-09 1 Introduction Three day spring school on basics of high throughput 16S rRNA gene sequencing data analysis. This spring school is organised in collaboration with VLAG graduate school, Laboratory of Microbiology, Systems and Synthetic Biology, Wageningen University &amp; Research, the Netherlands and Department of Mathematics and Statistics University of Turku, Finland. This year it will be held at Wageningen University &amp; Research. We will cover topics related to basics of sequencing and microbial community analysis. We will use NG-Tax and R based tools like Phyloseq, microbiome and ggplot2 for downstream data analysis and visualization. 1.1 Preparing for the course We recommend using your own laptop. If this is not possible, kindly contact the organizers. Install the following software before the course, if possible: R version 3.4 R Studio phyloseq microbiome ggplot2 R graphics cookbook The materials for the summer school will be made available through this website soon. The script to set-up the RStudio environment with required package installations can be found in the folder named scripts/setup_microbiome_analysis.R. Download the master brach of the the github repository for the course. Unzip the Microbial-bioinformatics-introductory-course-Material-2018-master.zip folder. open the microbiometutorials.Rproj Useful links RMarkdown List of R tools for microbiome analysis 1.2 Useful functions Base R R Markdown RStudio IDE ggplot2 1.3 Focus The primary aim is introduce microbial community data analysis. There will be talks and discussion on theory and methodology for analysis of microbial community data. We will cover topics ranging from design of studies, sequencing technologies, importance of controls and standardized DNA processing. Supervised hands-on training covering analyses from raw reads using NG-Tax, downstream analysis in R for exploration and analysis of microbiome sequencing data will be priority. There will be a strong focus on using R, R Studio for moving towards reproducible and open science. 1.4 Target audience Anyone who plans to or is currently doing high throughput microbial community analysis. No prior knowledge of R software is required. 1.5 License The 2-Clause BSD License SPDX short identifier: BSD-2-Clause Further resources on the 2-clause BSD license Note: This license has also been called the “Simplified BSD License” and the “FreeBSD License”. See also the 3-clause BSD License. Copyright 2018-2020 Sudarshan A. Shetty and Leo Lahti Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. "],
["set-up-and-pre-processing.html", "2 Set-up and Pre-processing 2.1 Structure 2.2 Making a phyloseq object 2.3 Read input to phyloseq object 2.4 Read the tree file. 2.5 Merge into phyloseq object. 2.6 Read test data 2.7 Pre-processing data check", " 2 Set-up and Pre-processing This tutorial will introduce you to basics of microbial community analysis. More importantly on how to look at you data and filter appropriately. We will use the Human microbiome project phase I data. The 16S rRNA gene variable region sequenced here is V1-V3. The raw reads were processed using QIIME 1.9.1, SortMeRNA, and OTU picking was done using the Closed-reference OTU-picking at 97% identity. The main tools used here are Phyloseq and microbiome Kindly cite all the packages and tools that you have used in your analysis. Also make sure that you provide the scripts you used for analysis as supplementary material with your research article. Check Quick-R. 2.1 Structure Let us create few folders to organize our analysis. While this can be personal preference, make sure you write the structure to guide others who do not know your data well. This is important like the old days hand-writing should be readable to understand. # Create Folders as following #Tables dir.create(&quot;tables&quot;) # Figures dir.create(&quot;figures&quot;) # Phyloseq objects dir.create(&quot;phyobjects&quot;) # Custom codes/notes dir.create(&quot;codes_notes&quot;) Load packages library(microbiome) # data analysis and visualisation library(phyloseq) # also the basis of data object. Data analysis and visualisation library(microbiomeutilities) # some utility tools library(RColorBrewer) # nice color options library(ggpubr) # publication quality figures, based on ggplot2 library(DT) # interactive tables in html and markdown library(data.table) # alternative to data.frame library(dplyr) # data handling 2.2 Making a phyloseq object This is the basis for your analyses. In this phyloseq object, information on OTUs, taxonomy, the phylogenetic tree and metadata is stored. A single object with all this information provides a very convinient way of handling data. Please remember that the metadata (i.e. mapping) file has to be in *.csv format (columns have sample attributes). Below you can see how the mapping file has been used. For more infromation: phyloseq Things to be done in QIIME terminal (if required): Important Note 2: If you have error in loading the biom files stating JSON or HDF5 then you need to convert it in to a JSON format. For this, use the following command within the QIIME terminal and not in R! # biom convert -i NGTaxMerged.biom -o ngtax_json.biom --table-type &quot;OTU table&quot; --to-json For more information on the biom format please click here. Important Note 3: The most recent version of NG-Tax does not have this issue. NOTE Update to latest version of Microbiome package to use the read_phyloseq function. This function can be used for reading other outputs (like .shared and consensus taxonomy files from mothur) into phyloseq object. 2.3 Read input to phyloseq object # may take anywhere between 30 seconds to 2 or more minutes to create a phyloseq object depending on the size of biom file and your PCs processing strength. pseq1 &lt;- read_phyloseq(otu.file = &quot;./input_data/NGTaxMerged_conv.biom&quot;, taxonomy.file = NULL, metadata.file = &quot;./input_data/mappingMerged_edit.csv&quot;, type = &quot;biom&quot;) ## Time to complete depends on OTU file size 2.4 Read the tree file. Note: requires a package called ape and the extension has to be “.tre” and not “.tree” (you can just change the name of the file extension) # Load tree file library(ape) ## ## Attaching package: &#39;ape&#39; ## The following object is masked from &#39;package:ggpubr&#39;: ## ## rotate treefile_p1 &lt;- read.tree(&quot;./input_data/combinedTree.tre&quot;) 2.5 Merge into phyloseq object. ps0 &lt;-merge_phyloseq(pseq1,treefile_p1) # ps1 is the first phyloseq object. rank_names(ps0) #we check the taxonomic rank information datatable(tax_table(ps0)) # the table is interactive you can scrol and search thorugh it for details. 2.6 Read test data If you dont have your own biom file, we have a test dataset. The data for tutorial is stored as *.rds file in the R project folder. We will use the Human microbiome project phase I data. ps0 &lt;- readRDS(&quot;ps.sub.rds&quot;) # use print option to see the data saved as phyloseq object. print(ps0) ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 4125 taxa and 474 samples ] ## sample_data() Sample Data: [ 474 samples by 31 sample variables ] ## tax_table() Taxonomy Table: [ 4125 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 4125 tips and 4124 internal nodes ] How many OTUs do you find? How many samples? Alternatively, you can also check you data as shown below: # check for number of samples nsamples(ps0) ## [1] 474 # check for number of samples ntaxa(ps0) ## [1] 4125 # check for sample variables sample_variables(ps0) ## [1] &quot;X.SampleID&quot; &quot;BarcodeSequence&quot; ## [3] &quot;LinkerPrimerSequence&quot; &quot;run_prefix&quot; ## [5] &quot;body_habitat&quot; &quot;body_product&quot; ## [7] &quot;body_site&quot; &quot;bodysite&quot; ## [9] &quot;dna_extracted&quot; &quot;elevation&quot; ## [11] &quot;env&quot; &quot;env_biome&quot; ## [13] &quot;env_feature&quot; &quot;env_material&quot; ## [15] &quot;env_package&quot; &quot;geo_loc_name&quot; ## [17] &quot;host_common_name&quot; &quot;host_scientific_name&quot; ## [19] &quot;host_subject_id&quot; &quot;host_taxid&quot; ## [21] &quot;latitude&quot; &quot;longitude&quot; ## [23] &quot;physical_specimen_location&quot; &quot;physical_specimen_remaining&quot; ## [25] &quot;psn&quot; &quot;public&quot; ## [27] &quot;sample_type&quot; &quot;scientific_name&quot; ## [29] &quot;sequencecenter&quot; &quot;title&quot; ## [31] &quot;Description&quot; # check for unique values in variables unique(sample_data(ps0)$scientific_name) ## [1] human gut metagenome human oral metagenome ## [3] human vaginal metagenome human skin metagenome ## 4 Levels: human gut metagenome ... human skin metagenome Which metagenomes do you see? Important Note 4 Always keep track of the filtering steps you performed and make a note of it! 2.7 Pre-processing data check 2.7.1 Sequencing depth Crude visualization of the sequencing depth for individual samples. # simple bar plot barplot(sample_sums(ps0), las=2) # here las=2 will rotate the label of X-axis # try typing ?barplot You can see there is uneven sequencing depth. summary(sample_sums(ps0)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2011 3142 4328 5184 5855 44106 From the above plot and summary, it is evident that there is a large difference in the sequencing depth. Let us check for our important variable p_seqdepth &lt;- plot_read_distribution(ps0, &quot;scientific_name&quot;, &quot;density&quot;) ## [1] &quot;Done plotting&quot; print(p_seqdepth) ggsave(&quot;./figures/read_distribution.pdf&quot;, height = 4, width = 6) What do you see from this plot? 2.7.2 Distribution of OTUs # We make a data table with information on the OTUs ps0_df_taxa =data.table(tax_table(ps0),OTUabundance = taxa_sums(ps0),OTU = taxa_names(ps0)) ps1_tax_plot &lt;- ggplot(ps0_df_taxa, aes(OTUabundance)) + geom_histogram() + ggtitle(&quot;Histogram of OTU (unique sequence) counts&quot;) + theme_bw() print(ps1_tax_plot) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Check how different phyla are represented in the total data. taxasums = rowSums(otu_table(ps0)) taxatable &lt;- as.data.frame.matrix(tax_table(ps0)) tax_plot1 &lt;- ggplot(taxatable, aes(x = taxasums, color = taxatable[, &quot;Phylum&quot;])) tax_plot1 &lt;- tax_plot1 + geom_line(size = 1.5, stat = &quot;density&quot;) tax_plot1 &lt;- tax_plot1 + theme_bw() tax_plot1 &lt;- tax_plot1 + guides(color=guide_legend(title=&quot;Phylum&quot;, nrow = 8)) tax_plot1 + scale_x_log10() + xlab(&quot;Log10 OTU Counts&quot;) ggsave(&quot;./figures/Distribution of OTUs.pdf&quot;, height = 4, width = 6) Another way to identify dominant and rare outs in the dataset is as follows: p &lt;- plot_taxa_prevalence(ps0, &quot;Phylum&quot;) p ggsave(&quot;./figures/OTU prevalence.pdf&quot;, height = 4, width = 6) # Set reference to check OTUs present in less than 10% p &lt;- p + geom_hline(yintercept = 0.1, color = &quot;steelblue&quot;) p # Set reference to check OTUs present in less than 5% p &lt;- p + geom_hline(yintercept = 0.05, color = &quot;red&quot;) p We can extract the prevalence and abundance data used for previous plot. prev_df &lt;- p$data nrow(prev_df) ## [1] 4125 Use this data for some checks. # check for distribution of prevalence values hist(prev_df$prevalence) # What can you see from the histogram? # Check total OTUs nrow(prev_df) ## [1] 4125 # Check how many are present in less than 5% samples nrow(prev_df[prev_df$prevalence &lt; 0.05, ]) ## [1] 3282 # now check if you put this as a threshold for filtering how many OTUs will you loose? nrow(prev_df[prev_df$prevalence &lt; 0.05, ])/nrow(prev_df) *100 ## [1] 79.56364 79.56% of the OTUs will be lost. Check with the prevalence plot and see which OTUs will be lost. This is a huge number. What could be the explaination for such high percent of low prevalance OTUs? Let us investigate. First check the environment/origin of samples. colnames(meta(ps0)) ## [1] &quot;X.SampleID&quot; &quot;BarcodeSequence&quot; ## [3] &quot;LinkerPrimerSequence&quot; &quot;run_prefix&quot; ## [5] &quot;body_habitat&quot; &quot;body_product&quot; ## [7] &quot;body_site&quot; &quot;bodysite&quot; ## [9] &quot;dna_extracted&quot; &quot;elevation&quot; ## [11] &quot;env&quot; &quot;env_biome&quot; ## [13] &quot;env_feature&quot; &quot;env_material&quot; ## [15] &quot;env_package&quot; &quot;geo_loc_name&quot; ## [17] &quot;host_common_name&quot; &quot;host_scientific_name&quot; ## [19] &quot;host_subject_id&quot; &quot;host_taxid&quot; ## [21] &quot;latitude&quot; &quot;longitude&quot; ## [23] &quot;physical_specimen_location&quot; &quot;physical_specimen_remaining&quot; ## [25] &quot;psn&quot; &quot;public&quot; ## [27] &quot;sample_type&quot; &quot;scientific_name&quot; ## [29] &quot;sequencecenter&quot; &quot;title&quot; ## [31] &quot;Description&quot; table(meta(ps0)$env_material) ## ## stool saliva mucus sebum ## 169 150 86 69 The samples here are * Stool * Saliva * Mucus * Sebum Although these all are host-associated samples, there is large variation in microbiota composition between body site. Analyses of the Microbial Diversity across the Human Microbiome Structure, function and diversity of the healthy human microbiome Thus, when comparing diverse samples, filtering based on prevalance has to be done cautiously and only after careful investigation. One of the commonly detected OTUs in sequencing data are mitochondria and chloroplast. datatable(tax_table(ps0)) # search in the table for mitochondria Remove the mitochondria OTUs. ps1 &lt;- subset_taxa(ps0, Family != &quot;mitochondria&quot;) print(ps1) ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 3690 taxa and 474 samples ] ## sample_data() Sample Data: [ 474 samples by 31 sample variables ] ## tax_table() Taxonomy Table: [ 3690 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 3690 tips and 3689 internal nodes ] # also check how many lost ntaxa(ps0)-ntaxa(ps1) ## [1] 435 # Save this filtered phyloseq object for later analysis saveRDS(ps1 , &quot;./phyobjects/ps1.rds&quot;) Check how many total reads are there in the data set. #total number of reads in the dataset reads_per_OTU &lt;- taxa_sums(ps1) print(sum(reads_per_OTU)) ## [1] 2398446 There are 2398446 reads in the total data set. How many OTUs are less than 10 reads and how many reads do they contain? print(length(reads_per_OTU[reads_per_OTU &lt; 10])) ## [1] 1678 print(sum(reads_per_OTU[reads_per_OTU &lt; 10])) ## [1] 5198 To put this into context; out of the 3690 OTUs, a 1678 OTUs contain less than 10 reads, which is: print((1678/3690)*100) ## [1] 45.47425 This is a major drawback of the OTU picking strategy. This percent can be lowered with NG_tax, DADA2, Deblur like approaches. Let us see how many singletons are there? length(which(taxa_sums(ps1) &lt;= 1)) ## [1] 613 Let us see how many doubletons are there? length(which(taxa_sums(ps1) == 2)) ## [1] 279 Let us see how many Singletons and doubletons are there? length(which(taxa_sums(ps1) &lt;= 2)) ## [1] 892 Singletons and doubletons round((892/3690)*100, digits = 2) ## [1] 24.17 24.17% of the OTUs are doubletons or singletons. This is suggests that there can be potentially spurious OTUs. It is commonly observed that a large fraction of taxa are rare. A nice reading for this topic is the review by Michael D. J. Lynch &amp; Josh D. Neufeld Ecology and exploration of the rare biosphere. sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 7 x64 (build 7601) Service Pack 1 ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Dutch_Netherlands.1252 LC_CTYPE=Dutch_Netherlands.1252 ## [3] LC_MONETARY=Dutch_Netherlands.1252 LC_NUMERIC=C ## [5] LC_TIME=Dutch_Netherlands.1252 ## ## attached base packages: ## [1] methods stats graphics grDevices utils datasets base ## ## other attached packages: ## [1] ape_5.1 dplyr_0.7.4 ## [3] data.table_1.10.4-3 DT_0.4 ## [5] ggpubr_0.1.6 magrittr_1.5 ## [7] RColorBrewer_1.1-2 microbiomeutilities_0.99.0 ## [9] microbiome_1.0.2 ggplot2_2.2.1 ## [11] phyloseq_1.23.1 ## ## loaded via a namespace (and not attached): ## [1] Biobase_2.38.0 viridis_0.5.1 tidyr_0.8.0 ## [4] jsonlite_1.5 viridisLite_0.3.0 splines_3.4.4 ## [7] foreach_1.4.4 shiny_1.0.5 assertthat_0.2.0 ## [10] stats4_3.4.4 yaml_2.1.18 ggrepel_0.7.0 ## [13] pillar_1.2.2 backports_1.1.2 lattice_0.20-35 ## [16] glue_1.2.0 digest_0.6.15 promises_1.0.1 ## [19] XVector_0.18.0 colorspace_1.3-2 htmltools_0.3.6 ## [22] httpuv_1.4.1 Matrix_1.2-14 plyr_1.8.4 ## [25] pkgconfig_2.0.1 pheatmap_1.0.8 bookdown_0.7 ## [28] zlibbioc_1.24.0 xtable_1.8-2 purrr_0.2.4 ## [31] scales_0.5.0 later_0.7.1 tibble_1.4.2 ## [34] mgcv_1.8-23 IRanges_2.12.0 BiocGenerics_0.24.0 ## [37] lazyeval_0.2.1 mime_0.5 survival_2.42-3 ## [40] evaluate_0.10.1 nlme_3.1-137 MASS_7.3-49 ## [43] vegan_2.5-1 tools_3.4.4 stringr_1.3.0 ## [46] S4Vectors_0.16.0 munsell_0.4.3 cluster_2.0.7-1 ## [49] bindrcpp_0.2.2 Biostrings_2.46.0 ade4_1.7-11 ## [52] compiler_3.4.4 rlang_0.2.0 rhdf5_2.22.0 ## [55] grid_3.4.4 iterators_1.0.9 biomformat_1.7.0 ## [58] htmlwidgets_1.2 crosstalk_1.0.0 igraph_1.2.1 ## [61] labeling_0.3 rmarkdown_1.9 gtable_0.2.0 ## [64] codetools_0.2-15 multtest_2.34.0 reshape2_1.4.3 ## [67] R6_2.2.2 gridExtra_2.3 knitr_1.20 ## [70] bindr_0.1.1 rprojroot_1.3-2 permute_0.9-4 ## [73] stringi_1.1.7 parallel_3.4.4 Rcpp_0.12.16 ## [76] xfun_0.1 "],
["alpha-diversities.html", "3 Alpha diversities 3.1 Equal sample sums 3.2 Diversities", " 3 Alpha diversities Alpha diversity measures are used to identify within individual taxa richness and evenness. The commonly used metrics/indices are Shannon, Inverse Simpson, Simpson, Gini, Observed and Chao1. These indices do not take into account the phylogeny of the taxa identified in sequencing. Phylogenetic diversity (Faith’s PD) uses phylogenetic distance to calculate the diversity of a given sample. It is important to note that, alpha diversity indices are sensitive to noise that is inherent to application of polymerase chain reaction and the sequencing errors. One has to consider the sequencing depth (how much of the taxa have been sampled) for each sample. If there is a large difference, then it is important to normalize the samples to equal sampling depth. First we look at the sampling depth (no. of reads per sample) Load packages library(microbiome) # data analysis and visualisation library(phyloseq) # also the basis of data object. Data analysis and visualisation library(microbiomeutilities) # some utility tools library(RColorBrewer) # nice color options library(ggpubr) # publication quality figures, based on ggplot2 library(DT) # interactive tables in html and markdown library(data.table) # alternative to data.frame library(dplyr) # data handling The data for tutorial is stored as *.rds file in the R project folder. We will use the filtered phyloseq object from Set-up and Pre-processing section. ps1 &lt;- readRDS(&quot;./phyobjects/ps1.rds&quot;) # use print option to see the data saved as phyloseq object. print(ps1) ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 3690 taxa and 474 samples ] ## sample_data() Sample Data: [ 474 samples by 31 sample variables ] ## tax_table() Taxonomy Table: [ 3690 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 3690 tips and 3689 internal nodes ] summary(sample_sums(ps1)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1286 3063 4192 5060 5790 41694 As is evident there is a large difference in the number of reads. Minimum is 1286 and maximum is 41694!! There is a ~30X difference! We can plot the rarefaction curve for the observed OTUs in the entire data set. out_tab &lt;- t(abundances(ps1)) p &lt;- vegan::rarecurve(out_tab, step = 50, label = FALSE, sample = min(rowSums(out_tab), col = &quot;blue&quot;, cex = 0.6)) Not all samples are reaching a plateau and that few samples have high number of reads and high number of OTUs. Since we are comparing different body sites, some are expected to have low bacterial load. We will normalize to the lowest depth of at least 2000 reads to keep maximum samples for our anlaysis. This can be varied to remove samples with lower sequencing depth. This decision will depend on the research question being addressed. 3.1 Equal sample sums set.seed(9242) # This will help in reprodcuing the filtering and nomalisation. ps0.rar &lt;- rarefy_even_depth(ps1, sample.size = 2000) ## You set `rngseed` to FALSE. Make sure you&#39;ve set &amp; recorded ## the random seed of your session for reproducibility. ## See `?set.seed` ## ... ## 12 samples removedbecause they contained fewer reads than `sample.size`. ## Up to first five removed samples are: ## 1927.SRS020470.SRX022097.SRR0576631927.SRS049823.SRX020523.SRR0464141927.SRS020119.SRX020676.SRR0478441927.SRS020606.SRX022097.SRR0576631927.SRS011634.SRX020659.SRR047489 ## ... ## 688OTUs were removed because they are no longer ## present in any sample after random subsampling ## ... saveRDS(ps0.rar, &quot;./phyobjects/ps0.rar.rds&quot;) Check how much data you have now ps0.rar &lt;- readRDS(&quot;./phyobjects/ps0.rar.rds&quot;) print(ps0.rar) ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 3002 taxa and 462 samples ] ## sample_data() Sample Data: [ 462 samples by 31 sample variables ] ## tax_table() Taxonomy Table: [ 3002 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 3002 tips and 3001 internal nodes ] # quick check for sampling depth barplot(sample_sums(ps0.rar), las =2) # quick check taxa prevalence p.rar &lt;- plot_taxa_prevalence(ps0.rar, &quot;Phylum&quot;) p.rar Compare this to taxa prevalence plot from previous section of the tutorial. Do you see any difference? 3.2 Diversities 3.2.1 Non-phylogenetic diversities For more diversity indices please refer to Microbiome Package Let use calculate diversity hmp.div &lt;- diversities(ps0.rar, index = &quot;all&quot;) datatable(hmp.div) This is one way to plot your data. # get the metadata out as seprate object hmp.meta &lt;- meta(ps0.rar) # Add the rownames as a new colum for easy integration later. hmp.meta$sam_name &lt;- rownames(hmp.meta) # Add the rownames to diversity table hmp.div$sam_name &lt;- rownames(hmp.div) # merge these two data frames into one div.df &lt;- merge(hmp.div,hmp.meta, by = &quot;sam_name&quot;) # check the tables colnames(div.df) ## [1] &quot;sam_name&quot; &quot;inverse_simpson&quot; ## [3] &quot;gini_simpson&quot; &quot;shannon&quot; ## [5] &quot;fisher&quot; &quot;coverage&quot; ## [7] &quot;X.SampleID&quot; &quot;BarcodeSequence&quot; ## [9] &quot;LinkerPrimerSequence&quot; &quot;run_prefix&quot; ## [11] &quot;body_habitat&quot; &quot;body_product&quot; ## [13] &quot;body_site&quot; &quot;bodysite&quot; ## [15] &quot;dna_extracted&quot; &quot;elevation&quot; ## [17] &quot;env&quot; &quot;env_biome&quot; ## [19] &quot;env_feature&quot; &quot;env_material&quot; ## [21] &quot;env_package&quot; &quot;geo_loc_name&quot; ## [23] &quot;host_common_name&quot; &quot;host_scientific_name&quot; ## [25] &quot;host_subject_id&quot; &quot;host_taxid&quot; ## [27] &quot;latitude&quot; &quot;longitude&quot; ## [29] &quot;physical_specimen_location&quot; &quot;physical_specimen_remaining&quot; ## [31] &quot;psn&quot; &quot;public&quot; ## [33] &quot;sample_type&quot; &quot;scientific_name&quot; ## [35] &quot;sequencecenter&quot; &quot;title&quot; ## [37] &quot;Description&quot; # Now use this data frame to plot p &lt;- ggboxplot(div.df, x = &quot;scientific_name&quot;, y = &quot;shannon&quot;, fill = &quot;scientific_name&quot;, palette = &quot;jco&quot;) p + rotate_x_text() colnames(hmp.div) ## [1] &quot;inverse_simpson&quot; &quot;gini_simpson&quot; &quot;shannon&quot; &quot;fisher&quot; ## [5] &quot;coverage&quot; &quot;sam_name&quot; Alternative way # convert phyloseq object into a long data format. div.df2 &lt;- div.df[,c(&quot;scientific_name&quot;, &quot;inverse_simpson&quot;, &quot;gini_simpson&quot;, &quot;shannon&quot;, &quot;fisher&quot;, &quot;coverage&quot;)] # the names are not pretty. we can replace them colnames(div.df2) &lt;- c(&quot;Location&quot;, &quot;Inverse Simpson&quot;, &quot;Gini-Simpson&quot;, &quot;Shannon&quot;, &quot;Fisher&quot;, &quot;Coverage&quot;) # check colnames(div.df2) ## [1] &quot;Location&quot; &quot;Inverse Simpson&quot; &quot;Gini-Simpson&quot; &quot;Shannon&quot; ## [5] &quot;Fisher&quot; &quot;Coverage&quot; div_df_melt &lt;- reshape2::melt(div.df2) ## Using Location as id variables head(div_df_melt) ## Location variable value ## 1 human gut metagenome Inverse Simpson 18.10774 ## 2 human gut metagenome Inverse Simpson 17.92356 ## 3 human oral metagenome Inverse Simpson 14.38766 ## 4 human oral metagenome Inverse Simpson 12.34309 ## 5 human gut metagenome Inverse Simpson 10.89604 ## 6 human gut metagenome Inverse Simpson 11.31670 The diversity indices are stored under column named variable. # Now use this data frame to plot p &lt;- ggboxplot(div_df_melt, x = &quot;Location&quot;, y = &quot;value&quot;, fill = &quot;Location&quot;, palette = &quot;jco&quot;, legend= &quot;right&quot;, facet.by = &quot;variable&quot;, scales = &quot;free&quot;) p &lt;- p + rotate_x_text() # we will remove the x axis lables p &lt;- p + rremove(&quot;x.text&quot;) p ggsave(&quot;./figures/Diversities.pdf&quot;, height = 4, width = 10) lev &lt;- levels(div_df_melt$Location) # get the variables # make a pairwise list that we want to compare. L.pairs &lt;- combn(seq_along(lev), 2, simplify = FALSE, FUN = function(i)lev[i]) pval &lt;- list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1), symbols = c(&quot;****&quot;, &quot;***&quot;, &quot;**&quot;, &quot;*&quot;, &quot;n.s&quot;)) p2 &lt;- p + stat_compare_means(comparisons = L.pairs, label = &quot;p.signif&quot;, symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1), symbols = c(&quot;****&quot;, &quot;***&quot;, &quot;**&quot;, &quot;*&quot;, &quot;n.s&quot;))) p2 3.2.2 Phylogenetic diversity Phylogenetic diversity is calculated using the picante package. library(picante) ps0.rar.otutab &lt;- as.data.frame(ps0.rar@otu_table) ps0.rar.tree &lt;- ps0.rar@phy_tree # hmp.meta from previous code chunks # We first need to check if the tree is rooted or not ps0.rar@phy_tree ## ## Phylogenetic tree with 3002 tips and 3001 internal nodes. ## ## Tip labels: ## 4440970, 627481, 86812, 4442127, 4394095, 32546, ... ## Node labels: ## , , , , , , ... ## ## Rooted; includes branch lengths. df.pd &lt;- pd(t(ps0.rar.otutab), ps0.rar.tree,include.root=T) # t(ou_table) transposes the table for use in picante and the tre file comes from the first code chunck we used to read tree file (see making a phyloseq object section). datatable(df.pd) now we need to plot PD. Check above how to get the metadata file from phyloseq object. # now we need to plot PD # We will add the results of PD to this file and then plot. hmp.meta$Phylogenetic_Diversity &lt;- df.pd$PD Plot pd.plot &lt;- ggboxplot(hmp.meta, x = &quot;scientific_name&quot;, y = &quot;Phylogenetic_Diversity&quot;, fill = &quot;scientific_name&quot;, palette = &quot;jco&quot;, ylab = &quot;Phylogenetic Diversity&quot;, xlab = &quot;Body site&quot;, legend = &quot;right&quot;) pd.plot &lt;- pd.plot + rotate_x_text() pd.plot + stat_compare_means(comparisons = L.pairs, label = &quot;p.signif&quot;, symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1), symbols = c(&quot;****&quot;, &quot;***&quot;, &quot;**&quot;, &quot;*&quot;, &quot;n.s&quot;))) NOTE: There are arguments both for and against the use of rarefying to equal library size. The application of normalization method will depend on the type of research question. It is always good to check if there is a correlation between increasing library sizes and richness. Observed OTUs and Phylogenetic diversity can be affected by library sizes. It is always good to check for this before making a choice. lib.div &lt;- diversities(ps1, index = &quot;all&quot;) lib.div2 &lt;- richness(ps1) # let us add library size lib.div$LibrarySize &lt;- sample_sums(ps1) lib.div$Richness &lt;- lib.div2$`0` colnames(lib.div) ## [1] &quot;inverse_simpson&quot; &quot;gini_simpson&quot; &quot;shannon&quot; &quot;fisher&quot; ## [5] &quot;coverage&quot; &quot;LibrarySize&quot; &quot;Richness&quot; ggscatter(lib.div, &quot;LibrarySize&quot;, &quot;shannon&quot;) + stat_cor(method = &quot;pearson&quot;) ggscatter(lib.div, &quot;inverse_simpson&quot;, &quot;LibrarySize&quot;, add = &quot;loess&quot;) + stat_cor(method = &quot;pearson&quot;) ggscatter(lib.div, &quot;Richness&quot;, &quot;LibrarySize&quot;, add = &quot;loess&quot;) + stat_cor(method = &quot;pearson&quot;, label.x = 100, label.y = 50000) sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 7 x64 (build 7601) Service Pack 1 ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Dutch_Netherlands.1252 LC_CTYPE=Dutch_Netherlands.1252 ## [3] LC_MONETARY=Dutch_Netherlands.1252 LC_NUMERIC=C ## [5] LC_TIME=Dutch_Netherlands.1252 ## ## attached base packages: ## [1] methods stats graphics grDevices utils datasets base ## ## other attached packages: ## [1] picante_1.6-2 nlme_3.1-137 ## [3] vegan_2.5-1 lattice_0.20-35 ## [5] permute_0.9-4 ape_5.1 ## [7] dplyr_0.7.4 data.table_1.10.4-3 ## [9] DT_0.4 ggpubr_0.1.6 ## [11] magrittr_1.5 RColorBrewer_1.1-2 ## [13] microbiomeutilities_0.99.0 microbiome_1.0.2 ## [15] ggplot2_2.2.1 phyloseq_1.23.1 ## ## loaded via a namespace (and not attached): ## [1] Biobase_2.38.0 viridis_0.5.1 tidyr_0.8.0 ## [4] jsonlite_1.5 viridisLite_0.3.0 splines_3.4.4 ## [7] foreach_1.4.4 shiny_1.0.5 assertthat_0.2.0 ## [10] stats4_3.4.4 yaml_2.1.18 ggrepel_0.7.0 ## [13] pillar_1.2.2 backports_1.1.2 glue_1.2.0 ## [16] digest_0.6.15 ggsignif_0.4.0 promises_1.0.1 ## [19] XVector_0.18.0 colorspace_1.3-2 htmltools_0.3.6 ## [22] httpuv_1.4.1 Matrix_1.2-14 plyr_1.8.4 ## [25] pkgconfig_2.0.1 pheatmap_1.0.8 bookdown_0.7 ## [28] zlibbioc_1.24.0 xtable_1.8-2 purrr_0.2.4 ## [31] scales_0.5.0 later_0.7.1 tibble_1.4.2 ## [34] mgcv_1.8-23 IRanges_2.12.0 BiocGenerics_0.24.0 ## [37] lazyeval_0.2.1 mime_0.5 survival_2.42-3 ## [40] evaluate_0.10.1 MASS_7.3-49 tools_3.4.4 ## [43] stringr_1.3.0 S4Vectors_0.16.0 munsell_0.4.3 ## [46] ggsci_2.8 cluster_2.0.7-1 bindrcpp_0.2.2 ## [49] Biostrings_2.46.0 ade4_1.7-11 compiler_3.4.4 ## [52] rlang_0.2.0 rhdf5_2.22.0 grid_3.4.4 ## [55] iterators_1.0.9 biomformat_1.7.0 htmlwidgets_1.2 ## [58] crosstalk_1.0.0 igraph_1.2.1 labeling_0.3 ## [61] rmarkdown_1.9 gtable_0.2.0 codetools_0.2-15 ## [64] multtest_2.34.0 reshape2_1.4.3 R6_2.2.2 ## [67] gridExtra_2.3 knitr_1.20 bindr_0.1.1 ## [70] rprojroot_1.3-2 stringi_1.1.7 parallel_3.4.4 ## [73] Rcpp_0.12.16 xfun_0.1 "],
["composition-plots.html", "4 Composition plots 4.1 Barplot counts 4.2 Barplot relative abundance 4.3 Heatmaps", " 4 Composition plots Barplots are an easy and intuitive way of visualising the composition of your samples. However, the way this is implented in phyloseq causes problems with the order of the taxa in the legend at higher taxonomic levels. We will use the filtered phyloseq object from Set-up and Pre-processing section. Load packages library(microbiome) # data analysis and visualisation library(phyloseq) # also the basis of data object. Data analysis and visualisation library(RColorBrewer) # nice color options library(ggpubr) # publication quality figures, based on ggplot2 library(dplyr) # data handling ps1 &lt;- readRDS(&quot;./phyobjects/ps1.rds&quot;) # use print option to see the data saved as phyloseq object. print(ps1) ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 3690 taxa and 474 samples ] ## sample_data() Sample Data: [ 474 samples by 31 sample variables ] ## tax_table() Taxonomy Table: [ 3690 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 3690 tips and 3689 internal nodes ] 4.1 Barplot counts ps1.com &lt;- ps1 # We need to set Palette taxic &lt;- as.data.frame(ps1.com@tax_table) # this will help in setting large color options #colourCount = length(unique(taxic$Family)) #define number of variable colors based on number of Family (change the level accordingly to phylum/class/order) #getPalette = colorRampPalette(brewer.pal(12, &quot;Paired&quot;)) # change the palette as well as the number of colors will change according to palette. taxic$OTU &lt;- rownames(taxic) # Add the OTU ids from OTU table into the taxa table at the end. colnames(taxic) # You can see that we now have extra taxonomy levels. ## [1] &quot;Kingdom&quot; &quot;Phylum&quot; &quot;Class&quot; &quot;Order&quot; &quot;Family&quot; &quot;Genus&quot; &quot;Species&quot; ## [8] &quot;OTU&quot; taxmat &lt;- as.matrix(taxic) # convert it into a matrix. new.tax &lt;- tax_table(taxmat) # convert into phyloseq compatible file. tax_table(ps1.com) &lt;- new.tax # incroporate into phyloseq Object # now edit the unclassified taxa # tax_table(ps1.com)[tax_table(ps1.com)[, &quot;Family&quot;] == &quot;f__&quot;, &quot;Family&quot;] &lt;- &quot;Unclassified family&quot; # We will also remove the &#39;f__&#39; patterns for cleaner labels # tax_table(ps1.com)[, colnames(tax_table(ps1.com))] &lt;- gsub(tax_table(ps1.com)[, # colnames(tax_table(ps1.com))], pattern = &quot;[a-z]__&quot;, replacement = &quot;&quot;) # it would be nice to have the Taxonomic names in italics. # for that we set this guide_italics &lt;- guides(fill = guide_legend(label.theme = element_text(size = 15, face = &quot;italic&quot;, colour = &quot;Black&quot;, angle = 0))) ## Now we need to plot at family level, We can do it as follows: # first remove the phy_tree ps1.com@phy_tree &lt;- NULL # Second merge at family level ps1.com.fam &lt;- aggregate_taxa(ps1.com, &quot;Family&quot;, top = 10) plot.composition.COuntAbun &lt;- plot_composition(ps1.com.fam) + theme(legend.position = &quot;bottom&quot;) + scale_fill_brewer(&quot;Family&quot;, palette = &quot;Paired&quot;) + theme_bw() + theme(axis.text.x = element_text(angle = 90)) + ggtitle(&quot;Relative abundance&quot;) + guide_italics + theme(legend.title = element_text(size=18)) plot.composition.COuntAbun #ggsave(&quot;./Test_Outputfiles/Family_barplot_CountAbundance.pdf&quot;, height = 6, width = 8) This plot is based on the reads/sample. You can see the reads are not evenly distributed over the samples, nevertheless their overall composition seems to be the same. The only thing that is different is the scaling. You don’t need any other normalisation alogorithms. To check this in the next step we plot the relative abundance. 4.2 Barplot relative abundance Make it relative abundance # the previous pseq object ps1.com.fam is only counts. # Use traqnsform function of microbiome to convert it to rel abun. ps1.com.rel &lt;- microbiome::transform(ps1.com, &quot;compositional&quot;) ps1.com.fam2 &lt;- aggregate_taxa(ps1.com.rel, &quot;Family&quot;, top = 10) plot.composition.relAbun &lt;- plot_composition(ps1.com.fam2, sample.sort = &quot;scientific_name&quot;, x.label = &quot;env_material&quot;) + theme(legend.position = &quot;bottom&quot;) + scale_fill_brewer(&quot;Family&quot;, palette = &quot;Paired&quot;) + theme_bw() + theme(axis.text.x = element_text(angle = 90)) + ggtitle(&quot;Relative abundance&quot;) + guide_italics + theme(legend.title = element_text(size=18)) plot.composition.relAbun #ggsave(&quot;./figures/Family_barplot_RelAbundance.pdf&quot;, height = 6, width = 8) 4.2.1 Barplot customize data.com &lt;- plot.composition.relAbun$data colnames(data.com) ## [1] &quot;OTU&quot; &quot;Sample&quot; &quot;Abundance&quot; &quot;xlabel&quot; p.com &lt;- ggplot(data.com, aes(x = Sample, y = Abundance, fill = OTU)) p.com &lt;- p.com + geom_bar(position = &quot;stack&quot;, stat = &quot;identity&quot;) p.com &lt;- p.com + scale_x_discrete(labels = data.com$xlabel, breaks = data.com$Sample) p.com &lt;- p.com + facet_grid(~xlabel, scales = &quot;free&quot;) + theme_bw() p.com &lt;- p.com + scale_fill_brewer(&quot;Family&quot;, palette = &quot;Paired&quot;) p.com &lt;- p.com + rremove(&quot;x.text&quot;) ggsave(&quot;./figures/Composition plots.pdf&quot;, height = 4, width = 6) for more information Microbiome tutorial 4.3 Heatmaps # base plot p.heat &lt;- ggplot(data.com, aes(x = Sample, y = OTU)) + geom_tile(aes(fill = Abundance)) # Change color p.heat &lt;- p.heat + scale_fill_distiller(&quot;Abundance&quot;, palette = &quot;RdYlBu&quot;) + theme_bw() # Make bacterial names italics p.heat &lt;- p.heat + theme(axis.text.y = element_text(colour = &#39;black&#39;, size = 10, face = &#39;italic&#39;)) # Make seperate samples based on main varaible p.heat &lt;- p.heat + facet_grid(~xlabel, scales = &quot;free&quot;) + rremove(&quot;x.text&quot;) p.heat &lt;- p.heat + ylab(&quot;Family&quot;) #Clean the x-axis p.heat &lt;- p.heat + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) # Clean the facet label box p.heat &lt;- p.heat + theme(legend.key = element_blank(), strip.background = element_rect(colour=&quot;black&quot;, fill=&quot;white&quot;)) print(p.heat) ggsave(&quot;./figures/Heatmap.pdf&quot;, height = 4, width = 6) # + geom_text(aes(label = round(Abundance)), size = 0.4) Extra Following is an example of customizing the plot using ggpubr. ps_df &lt;- microbiomeutilities::phy_to_ldf(ps1.com, transform.counts = &quot;compositional&quot;) ## An additonal column Sam_rep with sample names is created for reference purpose colnames(ps_df) ## [1] &quot;OTUID&quot; &quot;Kingdom&quot; ## [3] &quot;Phylum&quot; &quot;Class&quot; ## [5] &quot;Order&quot; &quot;Family&quot; ## [7] &quot;Genus&quot; &quot;Species&quot; ## [9] &quot;OTU&quot; &quot;Sam_rep&quot; ## [11] &quot;Abundance&quot; &quot;X.SampleID&quot; ## [13] &quot;BarcodeSequence&quot; &quot;LinkerPrimerSequence&quot; ## [15] &quot;run_prefix&quot; &quot;body_habitat&quot; ## [17] &quot;body_product&quot; &quot;body_site&quot; ## [19] &quot;bodysite&quot; &quot;dna_extracted&quot; ## [21] &quot;elevation&quot; &quot;env&quot; ## [23] &quot;env_biome&quot; &quot;env_feature&quot; ## [25] &quot;env_material&quot; &quot;env_package&quot; ## [27] &quot;geo_loc_name&quot; &quot;host_common_name&quot; ## [29] &quot;host_scientific_name&quot; &quot;host_subject_id&quot; ## [31] &quot;host_taxid&quot; &quot;latitude&quot; ## [33] &quot;longitude&quot; &quot;physical_specimen_location&quot; ## [35] &quot;physical_specimen_remaining&quot; &quot;psn&quot; ## [37] &quot;public&quot; &quot;sample_type&quot; ## [39] &quot;scientific_name&quot; &quot;sequencecenter&quot; ## [41] &quot;title&quot; &quot;Description&quot; # this data.frame can be used to customize several plots. # example boxplot at phylum level p.box &lt;- ggstripchart(ps_df, &quot;scientific_name&quot;, &quot;Abundance&quot;, facet.by = &quot;Phylum&quot;, color = &quot;scientific_name&quot;, palette = &quot;jco&quot;) p.box + rremove(&quot;x.text&quot;) sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 7 x64 (build 7601) Service Pack 1 ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Dutch_Netherlands.1252 LC_CTYPE=Dutch_Netherlands.1252 ## [3] LC_MONETARY=Dutch_Netherlands.1252 LC_NUMERIC=C ## [5] LC_TIME=Dutch_Netherlands.1252 ## ## attached base packages: ## [1] methods stats graphics grDevices utils datasets base ## ## other attached packages: ## [1] bindrcpp_0.2.2 dplyr_0.7.4 ggpubr_0.1.6 ## [4] magrittr_1.5 RColorBrewer_1.1-2 microbiome_1.0.2 ## [7] ggplot2_2.2.1 phyloseq_1.23.1 ## ## loaded via a namespace (and not attached): ## [1] ggrepel_0.7.0 Rcpp_0.12.16 ## [3] ape_5.1 lattice_0.20-35 ## [5] tidyr_0.8.0 Biostrings_2.46.0 ## [7] assertthat_0.2.0 rprojroot_1.3-2 ## [9] digest_0.6.15 foreach_1.4.4 ## [11] R6_2.2.2 plyr_1.8.4 ## [13] backports_1.1.2 stats4_3.4.4 ## [15] evaluate_0.10.1 pillar_1.2.2 ## [17] zlibbioc_1.24.0 rlang_0.2.0 ## [19] lazyeval_0.2.1 data.table_1.10.4-3 ## [21] vegan_2.5-1 S4Vectors_0.16.0 ## [23] Matrix_1.2-14 rmarkdown_1.9 ## [25] labeling_0.3 splines_3.4.4 ## [27] stringr_1.3.0 igraph_1.2.1 ## [29] pheatmap_1.0.8 munsell_0.4.3 ## [31] compiler_3.4.4 xfun_0.1 ## [33] pkgconfig_2.0.1 BiocGenerics_0.24.0 ## [35] multtest_2.34.0 mgcv_1.8-23 ## [37] htmltools_0.3.6 tidyselect_0.2.4 ## [39] biomformat_1.7.0 tibble_1.4.2 ## [41] gridExtra_2.3 bookdown_0.7 ## [43] IRanges_2.12.0 codetools_0.2-15 ## [45] permute_0.9-4 viridisLite_0.3.0 ## [47] MASS_7.3-49 grid_3.4.4 ## [49] nlme_3.1-137 jsonlite_1.5 ## [51] gtable_0.2.0 scales_0.5.0 ## [53] stringi_1.1.7 XVector_0.18.0 ## [55] reshape2_1.4.3 viridis_0.5.1 ## [57] ggsci_2.8 iterators_1.0.9 ## [59] tools_3.4.4 microbiomeutilities_0.99.0 ## [61] ade4_1.7-11 Biobase_2.38.0 ## [63] glue_1.2.0 purrr_0.2.4 ## [65] parallel_3.4.4 survival_2.42-3 ## [67] yaml_2.1.18 colorspace_1.3-2 ## [69] rhdf5_2.22.0 cluster_2.0.7-1 ## [71] knitr_1.20 bindr_0.1.1 "],
["beta-diversity-metrics.html", "5 Beta diversity metrics 5.1 Phylogenetic beta-diversity metrics 5.2 Population-level Density landscapes 5.3 PERMANOVA 5.4 Checking the homogeneity condition", " 5 Beta diversity metrics Beta-diversity: Measures for differences between samples from different groups to identify if there are differences in the overall community composition and structure. Load packages and data library(microbiome) # data analysis and visualisation library(phyloseq) # also the basis of data object. Data analysis and visualisation library(RColorBrewer) # nice color options library(ggpubr) # publication quality figures, based on ggplot2 library(dplyr) # data handling For more information: Ordination. Waste Not, Want Not: Why Rarefying Microbiome Data Is Inadmissible. Normalisation and data transformation. What is Constrained and Unconstrained Ordination. Microbiome Datasets Are Compositional: And This Is Not Optional Compositional analysis: a valid approach to analyze microbiome high-throughput sequencing data # read non rarefied data ps1 &lt;- readRDS(&quot;./phyobjects/ps1.rds&quot;) # read rarefied data ps0.rar.rds &lt;- readRDS(&quot;./phyobjects/ps0.rar.rds&quot;) # use print option to see the data saved as phyloseq object. 5.1 Phylogenetic beta-diversity metrics 5.1.1 Unweighted Unifrac Unweighted Unifrac is based on presence/absence of different taxa and abundance is not important. However, it is sensitive to the sequencing depth. If a sample is sequenced more than the others then it may have many OTUs (most of them unique) consequently affecting the unifrac dissimilarity estimation. ordu.unwt.uni &lt;- ordinate(ps0.rar.rds , &quot;PCoA&quot;, &quot;unifrac&quot;, weighted=F) # check for Eigen values # barplot(ordu.unwt.uni$values$Eigenvalues[1:10]) unwt.unifrac &lt;- plot_ordination(ps0.rar.rds, ordu.unwt.uni, color=&quot;scientific_name&quot;) unwt.unifrac &lt;- unwt.unifrac + ggtitle(&quot;Unweighted UniFrac&quot;) + geom_point(size = 2) unwt.unifrac &lt;- unwt.unifrac + theme_classic() + scale_color_brewer(&quot;Location&quot;, palette = &quot;Set2&quot;) print(unwt.unifrac) 5.1.2 Weighted Unifrac Weighted Unifrac will consider the abundances of different taxa. ps1.rel &lt;- microbiome::transform(ps1, &quot;compositional&quot;) ordu.wt.uni &lt;- ordinate(ps1.rel , &quot;PCoA&quot;, &quot;unifrac&quot;, weighted=T) # check for Eigen values # barplot(ordu.unwt.uni$values$Eigenvalues[1:10]) wt.unifrac &lt;- plot_ordination(ps1.rel, ordu.wt.uni, color=&quot;scientific_name&quot;) wt.unifrac &lt;- wt.unifrac + ggtitle(&quot;Weighted UniFrac&quot;) + geom_point(size = 2) wt.unifrac &lt;- wt.unifrac + theme_classic() + scale_color_brewer(&quot;Location&quot;, palette = &quot;Set2&quot;) print(wt.unifrac) print(wt.unifrac + stat_ellipse()) The figure brings forward an important characteristics of microbiome data called the ‘Horse-shoe effect’. An investigation and explaination for this can be found in the article by Morton JT., et al. 2017 Uncovering the Horseshoe Effect in Microbial Analyses. Another important aspect regarding weighted unifrac is its property of having heavier weights for abunant taxa. To detect changes in moderately abundant lineages an extenstion called generalized (UniFrac distance)(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3413390/) has been developed. In this test data, we expect sufficient biological variation in composition between sites and hence, we do not apply GUniFrac. Note: It is crucial to understand the biological features of the samples. Although these are exploratory approaches, it is important to differentiate between biological signal and technical artifacts. 5.2 Population-level Density landscapes p &lt;- microbiome::plot_landscape(ps1.rel, &quot;NMDS&quot;, &quot;bray&quot;, col = &quot;scientific_name&quot;) + labs(title = paste(&quot;NMDS / Bray-Curtis&quot;)) p + scale_color_brewer(palette = &quot;Dark2&quot;)+ scale_fill_gradient(low = &quot;#e0ecf4&quot;, high = &quot;#6e016b&quot;) ## Scale for &#39;fill&#39; is already present. Adding another scale for &#39;fill&#39;, ## which will replace the existing scale. 5.3 PERMANOVA Permutational multivariate analysis of variance further reading library(vegan) ## Loading required package: permute ## Loading required package: lattice ## This is vegan 2.5-1 metadf &lt;- data.frame(sample_data(ps1.rel)) unifrac.dist &lt;- UniFrac(ps1.rel, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast = TRUE) permanova &lt;- adonis(unifrac.dist ~ scientific_name, data = metadf) permanova ## ## Call: ## adonis(formula = unifrac.dist ~ scientific_name, data = metadf) ## ## Permutation: free ## Number of permutations: 999 ## ## Terms added sequentially (first to last) ## ## Df SumsOfSqs MeanSqs F.Model R2 Pr(&gt;F) ## scientific_name 3 61.496 20.4985 410.98 0.72401 0.001 *** ## Residuals 470 23.442 0.0499 0.27599 ## Total 473 84.938 1.00000 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 5.4 Checking the homogeneity condition Type ?betadisper in R console for more information. ps.disper &lt;- betadisper(unifrac.dist, metadf$scientific_name) permutest(ps.disper, pairwise = TRUE) ## ## Permutation test for homogeneity of multivariate dispersions ## Permutation: free ## Number of permutations: 999 ## ## Response: Distances ## Df Sum Sq Mean Sq F N.Perm Pr(&gt;F) ## Groups 3 0.9125 0.304150 22.998 999 0.001 *** ## Residuals 470 6.2158 0.013225 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Pairwise comparisons: ## (Observed p-value below diagonal, permuted p-value above diagonal) ## human gut metagenome human oral metagenome ## human gut metagenome 1.0000e-03 ## human oral metagenome 6.4361e-08 ## human vaginal metagenome 2.0164e-07 3.0628e-16 ## human skin metagenome 1.7519e-01 7.3652e-02 ## human vaginal metagenome human skin metagenome ## human gut metagenome 1.0000e-03 0.183 ## human oral metagenome 1.0000e-03 0.081 ## human vaginal metagenome 0.001 ## human skin metagenome 1.8573e-04 sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 7 x64 (build 7601) Service Pack 1 ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Dutch_Netherlands.1252 LC_CTYPE=Dutch_Netherlands.1252 ## [3] LC_MONETARY=Dutch_Netherlands.1252 LC_NUMERIC=C ## [5] LC_TIME=Dutch_Netherlands.1252 ## ## attached base packages: ## [1] methods stats graphics grDevices utils datasets base ## ## other attached packages: ## [1] vegan_2.5-1 lattice_0.20-35 permute_0.9-4 ## [4] dplyr_0.7.4 ggpubr_0.1.6 magrittr_1.5 ## [7] RColorBrewer_1.1-2 microbiome_1.0.2 ggplot2_2.2.1 ## [10] phyloseq_1.23.1 ## ## loaded via a namespace (and not attached): ## [1] xfun_0.1 purrr_0.2.4 reshape2_1.4.3 ## [4] splines_3.4.4 rhdf5_2.22.0 colorspace_1.3-2 ## [7] htmltools_0.3.6 stats4_3.4.4 yaml_2.1.18 ## [10] mgcv_1.8-23 survival_2.42-3 rlang_0.2.0 ## [13] pillar_1.2.2 glue_1.2.0 BiocGenerics_0.24.0 ## [16] bindrcpp_0.2.2 bindr_0.1.1 foreach_1.4.4 ## [19] plyr_1.8.4 stringr_1.3.0 zlibbioc_1.24.0 ## [22] Biostrings_2.46.0 munsell_0.4.3 gtable_0.2.0 ## [25] codetools_0.2-15 evaluate_0.10.1 labeling_0.3 ## [28] Biobase_2.38.0 knitr_1.20 IRanges_2.12.0 ## [31] biomformat_1.7.0 parallel_3.4.4 Rcpp_0.12.16 ## [34] backports_1.1.2 scales_0.5.0 S4Vectors_0.16.0 ## [37] jsonlite_1.5 XVector_0.18.0 digest_0.6.15 ## [40] stringi_1.1.7 bookdown_0.7 grid_3.4.4 ## [43] ade4_1.7-11 rprojroot_1.3-2 tools_3.4.4 ## [46] lazyeval_0.2.1 tibble_1.4.2 cluster_2.0.7-1 ## [49] tidyr_0.8.0 ape_5.1 pkgconfig_2.0.1 ## [52] MASS_7.3-49 Matrix_1.2-14 data.table_1.10.4-3 ## [55] assertthat_0.2.0 rmarkdown_1.9 iterators_1.0.9 ## [58] R6_2.2.2 multtest_2.34.0 igraph_1.2.1 ## [61] nlme_3.1-137 compiler_3.4.4 "],
["core-microbiota.html", "6 Core microbiota 6.1 Core microbiota anlaysis 6.2 Core abundance and diversity 6.3 Core visualization", " 6 Core microbiota For more information: The adult intestinal core microbiota is determined by analysis depth and health status. Intestinal microbiome landscaping: insight in community assemblage and implications for microbial modulation strategies. Intestinal Microbiota in Healthy Adults: Temporal Analysis Reveals Individual and Common Core and Relation to Intestinal Symptoms. library(microbiome) # data analysis and visualisation library(phyloseq) # also the basis of data object. Data analysis and visualisation library(RColorBrewer) # nice color options library(ggpubr) # publication quality figures, based on ggplot2 library(dplyr) # data handling 6.1 Core microbiota anlaysis We will use the filtered phyloseq object from previous tutorial. We will use the filtered phyloseq object from the first section for pre-processioning. # read non rarefied data ps1 &lt;- readRDS(&quot;./phyobjects/ps1.rds&quot;) # use print option to see the data saved as phyloseq object. Subset the data to keep only stool samples. ps1.stool &lt;- subset_samples(ps1, bodysite == &quot;Stool&quot;) # convert to relative abundance ps1.stool.rel &lt;- microbiome::transform(ps1.stool, &quot;compositional&quot;) print(ps1.stool.rel) ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 3690 taxa and 169 samples ] ## sample_data() Sample Data: [ 169 samples by 31 sample variables ] ## tax_table() Taxonomy Table: [ 3690 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 3690 tips and 3689 internal nodes ] ps1.stool.rel2 &lt;- prune_taxa(taxa_sums(ps1.stool.rel) &gt; 0, ps1.stool.rel) print(ps1.stool.rel2) ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 2717 taxa and 169 samples ] ## sample_data() Sample Data: [ 169 samples by 31 sample variables ] ## tax_table() Taxonomy Table: [ 2717 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 2717 tips and 2716 internal nodes ] Check of the core OTUs core.taxa.standard &lt;- core_members(ps1.stool.rel2, detection = 0.001, prevalence = 50/100) print(core.taxa.standard) ## [1] &quot;191483&quot; &quot;194909&quot; &quot;197214&quot; &quot;177343&quot; &quot;184753&quot; &quot;560336&quot; &quot;192684&quot; ## [8] &quot;535375&quot; &quot;193233&quot; &quot;772282&quot; &quot;4325533&quot; &quot;850586&quot; &quot;196219&quot; &quot;180082&quot; ## [15] &quot;330458&quot; &quot;173996&quot; There are 16 OTUs that are core based on the cut-offs for prevalence and detection we choose. However, we only see IDs, not very informative. We can get the classification of these as below. # Extract the taxonomy table taxonomy &lt;- as.data.frame(tax_table(ps1.stool.rel2)) # Subset this taxonomy table to include only core OTUs core_taxa_id &lt;- subset(taxonomy, rownames(taxonomy) %in% core.taxa.standard) DT::datatable(core_taxa_id) 6.2 Core abundance and diversity Total core abundance in each sample (sum of abundances of the core members): core.abundance &lt;- sample_sums(core(ps1.stool.rel2, detection = 0.001, prevalence = 50/100)) DT::datatable(as.data.frame(core.abundance)) 6.3 Core visualization 6.3.1 Core heatmaps This visualization method has been used for instance in Intestinal microbiome landscaping: insight in community assemblage and implications for microbial modulation strategies. Note that you can order the taxa on the heatmap with the order.taxa argument. # Core with compositionals: prevalences &lt;- seq(.05, 1, .05) detections &lt;- 10^seq(log10(1e-3), log10(.2), length = 10) # Also define gray color palette gray &lt;- gray(seq(0,1,length=5)) p.core &lt;- plot_core(ps1.stool.rel2, plot.type = &quot;heatmap&quot;, colours = gray, prevalences = prevalences, detections = detections, min.prevalence = .5) + xlab(&quot;Detection Threshold (Relative Abundance (%))&quot;) print(p.core) # Same with the viridis color palette # color-blind friendly and uniform # options: viridis, magma, plasma, inferno # https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html # Also discrete=TRUE versions available library(viridis) ## Loading required package: viridisLite print(p.core + scale_fill_viridis()) ## Scale for &#39;fill&#39; is already present. Adding another scale for &#39;fill&#39;, ## which will replace the existing scale. Color change # Core with compositionals: prevalences &lt;- seq(.05, 1, .05) detections &lt;- 10^seq(log10(1e-3), log10(.2), length = 10) # Also define gray color palette gray &lt;- gray(seq(0,1,length=5)) p.core &lt;- plot_core(ps1.stool.rel2, plot.type = &quot;heatmap&quot;, colours = rev(brewer.pal(5, &quot;Spectral&quot;)), prevalences = prevalences, detections = detections, min.prevalence = .5) + xlab(&quot;Detection Threshold (Relative Abundance (%))&quot;) print(p.core) We have a custom script to format this figure which can be found in scripts folder in the RProject. source(&quot;./scripts/plot_core_assist.R&quot;) plot_data &lt;- p.core$data df_plot &lt;- plot_core_assist(plot_data, tax_table(ps1.stool.rel2), levels = &quot;Family&quot;) p.core$data &lt;- df_plot plot(p.core + theme(axis.text.y = element_text(face=&quot;italic&quot;))) sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 7 x64 (build 7601) Service Pack 1 ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Dutch_Netherlands.1252 LC_CTYPE=Dutch_Netherlands.1252 ## [3] LC_MONETARY=Dutch_Netherlands.1252 LC_NUMERIC=C ## [5] LC_TIME=Dutch_Netherlands.1252 ## ## attached base packages: ## [1] methods stats graphics grDevices utils datasets base ## ## other attached packages: ## [1] bindrcpp_0.2.2 viridis_0.5.1 viridisLite_0.3.0 ## [4] dplyr_0.7.4 ggpubr_0.1.6 magrittr_1.5 ## [7] RColorBrewer_1.1-2 microbiome_1.0.2 ggplot2_2.2.1 ## [10] phyloseq_1.23.1 ## ## loaded via a namespace (and not attached): ## [1] Biobase_2.38.0 tidyr_0.8.0 jsonlite_1.5 ## [4] splines_3.4.4 foreach_1.4.4 shiny_1.0.5 ## [7] assertthat_0.2.0 stats4_3.4.4 yaml_2.1.18 ## [10] pillar_1.2.2 backports_1.1.2 lattice_0.20-35 ## [13] glue_1.2.0 digest_0.6.15 promises_1.0.1 ## [16] XVector_0.18.0 colorspace_1.3-2 htmltools_0.3.6 ## [19] httpuv_1.4.1 Matrix_1.2-14 plyr_1.8.4 ## [22] pkgconfig_2.0.1 bookdown_0.7 zlibbioc_1.24.0 ## [25] purrr_0.2.4 xtable_1.8-2 scales_0.5.0 ## [28] later_0.7.1 tibble_1.4.2 mgcv_1.8-23 ## [31] IRanges_2.12.0 DT_0.4 BiocGenerics_0.24.0 ## [34] lazyeval_0.2.1 survival_2.42-3 mime_0.5 ## [37] evaluate_0.10.1 nlme_3.1-137 MASS_7.3-49 ## [40] vegan_2.5-1 tools_3.4.4 data.table_1.10.4-3 ## [43] stringr_1.3.0 S4Vectors_0.16.0 munsell_0.4.3 ## [46] cluster_2.0.7-1 Biostrings_2.46.0 ade4_1.7-11 ## [49] compiler_3.4.4 rlang_0.2.0 rhdf5_2.22.0 ## [52] grid_3.4.4 iterators_1.0.9 biomformat_1.7.0 ## [55] htmlwidgets_1.2 crosstalk_1.0.0 igraph_1.2.1 ## [58] labeling_0.3 rmarkdown_1.9 gtable_0.2.0 ## [61] codetools_0.2-15 multtest_2.34.0 reshape2_1.4.3 ## [64] R6_2.2.2 gridExtra_2.3 knitr_1.20 ## [67] bindr_0.1.1 rprojroot_1.3-2 permute_0.9-4 ## [70] ape_5.1 stringi_1.1.7 parallel_3.4.4 ## [73] Rcpp_0.12.16 tidyselect_0.2.4 xfun_0.1 "],
["inference-of-microbial-ecological-networks.html", "7 Inference of Microbial Ecological Networks 7.1 Prepare data for SpiecEasi 7.2 SPIEC-EASI network reconstruction 7.3 Network properties", " 7 Inference of Microbial Ecological Networks More information on SPIEC-EASI. The input for SPIEC-EASI is a counts table. The normalization and tranformation is done by the function. This is very handy tool. This step is heavy on computational memory and slow. Noise filtered OTU-OTU level covariance would be ideal. Load packages and data library(devtools) install_github(&quot;zdk123/SpiecEasi&quot;) # Other packages you need to install are install.packages(&quot;igraph&quot;) install.packages(&quot;intergraph&quot;) install.packages(&quot;GGally&quot;) devtools::install_github(&quot;briatte/ggnet&quot;) install.packages(&quot;network&quot;) install.packages(&quot;ggnetwork&quot;) library(microbiome) # data analysis and visualisation library(phyloseq) # also the basis of data object. Data analysis and visualisation library(RColorBrewer) # nice color options library(ggpubr) # publication quality figures, based on ggplot2 library(dplyr) # data handling library(SpiecEasi) # Network analysis for sparse compositional data library(network) library(intergraph) #devtools::install_github(&quot;briatte/ggnet&quot;) library(ggnet) library(igraph) Read data ps1 &lt;- readRDS(&quot;./phyobjects/ps1.rds&quot;) Select only stool samples We will subset our data to include only stool samples. ps1.stool &lt;- subset_samples(ps1, bodysite == &quot;Stool&quot;) For testing reduce the number of OTUs ps1.stool.otu &lt;- prune_taxa(taxa_sums(ps1.stool) &gt; 100, ps1.stool) # Add taxonomic classification to OTU ID ps1.stool.otu.f &lt;- microbiomeutilities::format_to_besthit(ps1.stool.otu) head(tax_table(ps1.stool)) ## Taxonomy Table: [6 taxa by 7 taxonomic ranks]: ## Kingdom Phylum Class ## 4440970 &quot;Bacteria&quot; &quot;TM7&quot; &quot;TM7-3&quot; ## 4299136 &quot;Bacteria&quot; &quot;TM7&quot; &quot;TM7-3&quot; ## 627481 &quot;Bacteria&quot; &quot;TM7&quot; &quot;TM7-3&quot; ## 86812 &quot;Bacteria&quot; &quot;Proteobacteria&quot; &quot;Epsilonproteobacteria&quot; ## 4442127 &quot;Bacteria&quot; &quot;Proteobacteria&quot; &quot;Epsilonproteobacteria&quot; ## 4425150 &quot;Bacteria&quot; &quot;Proteobacteria&quot; &quot;Epsilonproteobacteria&quot; ## Order Family Genus Species ## 4440970 &quot;CW040&quot; &quot;F16&quot; NA NA ## 4299136 &quot;CW040&quot; &quot;F16&quot; NA NA ## 627481 &quot;I025&quot; &quot;Rs-045&quot; NA NA ## 86812 &quot;Campylobacterales&quot; &quot;Campylobacteraceae&quot; &quot;Campylobacter&quot; NA ## 4442127 &quot;Campylobacterales&quot; &quot;Campylobacteraceae&quot; &quot;Campylobacter&quot; NA ## 4425150 &quot;Campylobacterales&quot; &quot;Campylobacteraceae&quot; &quot;Campylobacter&quot; NA Check the difference in two phyloseq objects. head(tax_table(ps1.stool.otu.f)) 7.1 Prepare data for SpiecEasi The calcualtion of SpiecEasi are time consuming. For this tutorial we will have the necessary input files for SpiecEasi. OTU table Taxonomy table We save it as .rds object. otu.c &lt;- t(otu_table(ps1.stool.otu.f)@.Data) #extract the otu table from phyloseq object tax.c &lt;- as.data.frame(tax_table(ps1.stool.otu.f)@.Data)#extract the taxonomy information head(tax.c) ## Domain Phylum Class ## OTU-359809:Sutterella Bacteria Proteobacteria Betaproteobacteria ## OTU-215097:Sutterella Bacteria Proteobacteria Betaproteobacteria ## OTU-179261:Sutterella Bacteria Proteobacteria Betaproteobacteria ## OTU-41229:Sutterella Bacteria Proteobacteria Betaproteobacteria ## OTU-4371362:Sutterella Bacteria Proteobacteria Betaproteobacteria ## OTU-178885:Sutterella Bacteria Proteobacteria Betaproteobacteria ## Order Family Genus ## OTU-359809:Sutterella Burkholderiales Alcaligenaceae Sutterella ## OTU-215097:Sutterella Burkholderiales Alcaligenaceae Sutterella ## OTU-179261:Sutterella Burkholderiales Alcaligenaceae Sutterella ## OTU-41229:Sutterella Burkholderiales Alcaligenaceae Sutterella ## OTU-4371362:Sutterella Burkholderiales Alcaligenaceae Sutterella ## OTU-178885:Sutterella Burkholderiales Alcaligenaceae Sutterella ## Species best_hit ## OTU-359809:Sutterella g__Sutterella OTU-359809:Sutterella ## OTU-215097:Sutterella g__Sutterella OTU-215097:Sutterella ## OTU-179261:Sutterella g__Sutterella OTU-179261:Sutterella ## OTU-41229:Sutterella g__Sutterella OTU-41229:Sutterella ## OTU-4371362:Sutterella g__Sutterella OTU-4371362:Sutterella ## OTU-178885:Sutterella g__Sutterella OTU-178885:Sutterella saveRDS(otu.c, &quot;input_data/stool.otu.c.rds&quot;) saveRDS(tax.c, &quot;input_data/stool.tax.c.rds&quot;) 7.2 SPIEC-EASI network reconstruction More information on SPIEC-EASI. This input for SPIEC-EASI is a counts table. The normalization and tranformation is done by the function. This is very handy tool. This step is heavy on computational memory and very slow. For this workshop we have already have the output and will skip this chuck. # In practice, use more repetitions set.seed(1244) net.c &lt;- spiec.easi(otu.c, method=&#39;mb&#39;, icov.select.params=list(rep.num=50)) # saveRDS(net.c, &quot;input_data/net.c.rds&quot;) #please use more numebr of rep.num (99 or 999) the paraemters ## Create graph object and get edge values We have save the output of net.c to save time The output of spiec.easi is stored in ./input_data/ as stool.net.c.rds. Read this file in R and follow the steps below. net.c &lt;- readRDS(&quot;input_data/stool.net.c.rds&quot;) n.c &lt;- symBeta(getOptBeta(net.c)) Add names to IDs We also add abundance values to vertex (nodes). colnames(n.c) &lt;- rownames(n.c) &lt;- colnames(otu.c) vsize &lt;- log2(apply(otu.c, 2, mean)) # add log abundance as properties of vertex/nodes. 7.2.1 Prepare data for plotting stool.ig &lt;- graph.adjacency(n.c, mode=&#39;undirected&#39;, add.rownames = TRUE, weighted = TRUE) stool.ig # we can see all the attributes and weights ## IGRAPH eabab7c UNW- 506 1865 -- ## + attr: name (v/c), TRUE (v/c), weight (e/n) ## + edges from eabab7c (vertex names): ## [1] OTU-359809:Sutterella--OTU-211706:Bacteroides ## [2] OTU-359809:Sutterella--OTU-198711:Bacteroides ## [3] OTU-359809:Sutterella--OTU-1105984:Bacteroides ## [4] OTU-359809:Sutterella--OTU-193233:Bacteroides ## [5] OTU-359809:Sutterella--OTU-544859:f__Ruminococcaceae ## [6] OTU-359809:Sutterella--OTU-1740499:Phascolarctobacterium ## [7] OTU-215097:Sutterella--OTU-320291:Bacteroides ## [8] OTU-215097:Sutterella--OTU-300650:Prevotella ## + ... omitted several edges #plot(stool.ig) set the layout option # check what is it? ?layout_with_fr coords.fdr = layout_with_fr(stool.ig) 7.2.2 igraph network E(stool.ig)[weight &gt; 0]$color&lt;-&quot;steelblue&quot; #now color the edges based on their values positive is steelblue E(stool.ig)[weight &lt; 0]$color&lt;-&quot;orange&quot; #now color the edges based on their values plot(stool.ig, layout=coords.fdr, vertex.size = 2, vertex.label.cex = 0.5) The visualisation can be enhanced using ggnet R package. stool.net &lt;- asNetwork(stool.ig) network::set.edge.attribute(stool.net, &quot;color&quot;, ifelse(stool.net %e% &quot;weight&quot; &gt; 0, &quot;steelblue&quot;, &quot;orange&quot;)) Start adding taxonomic information. colnames(tax_table(ps1.stool.otu.f)) ## [1] &quot;Domain&quot; &quot;Phylum&quot; &quot;Class&quot; &quot;Order&quot; &quot;Family&quot; &quot;Genus&quot; ## [7] &quot;Species&quot; &quot;best_hit&quot; phyla &lt;- map_levels(colnames(otu.c), from = &quot;best_hit&quot;, to = &quot;Phylum&quot;, tax_table(ps1.stool.otu.f)) stool.net %v% &quot;Phylum&quot; &lt;- phyla stool.net %v% &quot;nodesize&quot; &lt;- vsize 7.2.3 Network plot mycolors &lt;- scale_color_manual(values = c(&quot;#a6cee3&quot;, &quot;#1f78b4&quot;, &quot;#b2df8a&quot;, &quot;#33a02c&quot;,&quot;#fb9a99&quot;,&quot;#e31a1c&quot;,&quot;#fdbf6f&quot;,&quot;#ff7f00&quot;,&quot;#cab2d6&quot;,&quot;#6a3d9a&quot;,&quot;#ffff99&quot;,&quot;#b15928&quot;)) p &lt;- ggnet2(stool.net, node.color = &quot;Phylum&quot;, label = TRUE, node.size = &quot;nodesize&quot;, label.size = 1, edge.color = &quot;color&quot;) + guides(color=guide_legend(title=&quot;Phylum&quot;), size = FALSE) + mycolors p p &lt;- ggnet2(stool.net, node.color = &quot;Phylum&quot;, label = TRUE, node.size = 2, label.size = 1, edge.color = &quot;color&quot;) + guides(color=guide_legend(title=&quot;Phylum&quot;), size = FALSE) + mycolors p 7.3 Network properties Check for the number of positive and negative edges. betaMat=as.matrix(symBeta(getOptBeta(net.c))) # We divide by two since an edge is represented by two entries in the matrix. positive=length(betaMat[betaMat&gt;0])/2 negative=length(betaMat[betaMat&lt;0])/2 total=length(betaMat[betaMat!=0])/2 7.3.1 Modularity in networks net.c ## Model: Meinshausen &amp; Buhlmann Graph Estimation (mb) ## selection criterion: stars ## Graph dimension: 506 ## sparsity level 0.01459711 mod.net &lt;- net.c$refit colnames(mod.net) &lt;- rownames(mod.net) &lt;- colnames(otu.c)#you can remove this vsize &lt;- log2(apply(otu.c, 2, mean))# value we may or may not use as vertex.attribute stool.ig.mod &lt;- graph.adjacency(mod.net, mode=&#39;undirected&#39;, add.rownames = TRUE) plot(stool.ig.mod) # we can see all the attributes and weights stool.net.mod &lt;- asNetwork(stool.ig.mod) phyla &lt;- map_levels(colnames(otu.c), from = &quot;best_hit&quot;, to = &quot;Phylum&quot;, tax_table(ps1.stool.otu.f)) stool.net.mod %v% &quot;Phylum&quot; &lt;- phyla stool.net.mod %v% &quot;nodesize&quot; &lt;- vsize 7.3.2 Network plot mycolors &lt;- scale_color_manual(values = c(&quot;#a6cee3&quot;, &quot;#1f78b4&quot;, &quot;#b2df8a&quot;, &quot;#33a02c&quot;,&quot;#fb9a99&quot;,&quot;#e31a1c&quot;,&quot;#fdbf6f&quot;,&quot;#ff7f00&quot;,&quot;#cab2d6&quot;,&quot;#6a3d9a&quot;,&quot;#ffff99&quot;,&quot;#b15928&quot;)) p &lt;- ggnet2(stool.net.mod, node.color = &quot;Phylum&quot;, label = TRUE, node.size = 2, label.size = 2) + guides(color=guide_legend(title=&quot;Phylum&quot;), size = FALSE) + mycolors p Identify modularity in networks. modules =cluster_fast_greedy(stool.ig.mod) print(modules) ## IGRAPH clustering fast greedy, groups: 9, mod: 0.5 ## + groups: ## $`1` ## [1] &quot;OTU-178885:Sutterella&quot; ## [2] &quot;OTU-529652:Sutterella&quot; ## [3] &quot;OTU-1135084:Bacteroides&quot; ## [4] &quot;OTU-196632:Clostridium&quot; ## [5] &quot;OTU-187668:Clostridium&quot; ## [6] &quot;OTU-176994:f__Ruminococcaceae&quot; ## [7] &quot;OTU-197649:Lachnospira&quot; ## [8] &quot;OTU-195752:Lachnospira&quot; ## [9] &quot;OTU-194734:Coprococcus&quot; ## + ... omitted several groups/vertices modularity(modules) ## [1] 0.5044993 V(stool.ig.mod)$color=modules$membership plot(stool.ig.mod, col = modules, vertex.size = 4, vertex.label = NA) stool.net.mod %v% &quot;membership&quot; &lt;- modules$membership p &lt;- ggnet2(stool.net.mod, node.color = &quot;membership&quot;, label = TRUE, node.size = &quot;nodesize&quot;, label.size = 2) + guides(color=guide_legend(title=&quot;membership&quot;), size = FALSE) + mycolors ## Scale for &#39;colour&#39; is already present. Adding another scale for ## &#39;colour&#39;, which will replace the existing scale. p Check which OTUs are part of different modules. modulesOneIndices=which(modules$membership==1) modulesOneOtus=modules$names[modulesOneIndices] modulesTwoIndices=which(modules$membership==2) modulesTwoOtus=modules$names[modulesTwoIndices] modulesThreeIndices=which(modules$membership==3) modulesThreeOtus=modules$names[modulesThreeIndices] modulesFourIndices=which(modules$membership==4) modulesFourOtus=modules$names[modulesFourIndices] modulesFiveIndices=which(modules$membership==5) modulesFiveOtus=modules$names[modulesFiveIndices] modulesSixIndices=which(modules$membership==6) modulesSixOtus=modules$names[modulesSixIndices] print(modulesFiveOtus) ## [1] &quot;OTU-181239:Bacteroides&quot; ## [2] &quot;OTU-192684:Bacteroides&quot; ## [3] &quot;OTU-178810:Bacteroides&quot; ## [4] &quot;OTU-194341:Bacteroides&quot; ## [5] &quot;OTU-187623:Bacteroides&quot; ## [6] &quot;OTU-197537:Bacteroides&quot; ## [7] &quot;OTU-174036:Bacteroides&quot; ## [8] &quot;OTU-176034:Bacteroides&quot; ## [9] &quot;OTU-772282:f__Rikenellaceae&quot; ## [10] &quot;OTU-4325533:f__Rikenellaceae&quot; ## [11] &quot;OTU-850586:Odoribacter&quot; ## [12] &quot;OTU-180082:Parabacteroides&quot; ## [13] &quot;OTU-361170:Bilophila&quot; ## [14] &quot;OTU-544859:f__Ruminococcaceae&quot; ## [15] &quot;OTU-332185:f__Ruminococcaceae&quot; ## [16] &quot;OTU-196713:f__Ruminococcaceae&quot; ## [17] &quot;OTU-554303:f__Ruminococcaceae&quot; ## [18] &quot;OTU-213487:f__Ruminococcaceae&quot; ## [19] &quot;OTU-178015:f__Ruminococcaceae&quot; ## [20] &quot;OTU-180067:f__Ruminococcaceae&quot; ## [21] &quot;OTU-190303:f__Ruminococcaceae&quot; ## [22] &quot;OTU-193915:f__Ruminococcaceae&quot; ## [23] &quot;OTU-195222:f__Ruminococcaceae&quot; ## [24] &quot;OTU-198404:f__Ruminococcaceae&quot; ## [25] &quot;OTU-191872:f__Ruminococcaceae&quot; ## [26] &quot;OTU-184876:Lachnospira&quot; ## [27] &quot;OTU-210542:Lachnospira&quot; ## [28] &quot;OTU-302503:f__Ruminococcaceae&quot; ## [29] &quot;OTU-1978955:f__Ruminococcaceae&quot; ## [30] &quot;OTU-177359:Coprococcus&quot; ## [31] &quot;OTU-187248:f__Lachnospiraceae&quot; ## [32] &quot;OTU-185588:f__Lachnospiraceae&quot; ## [33] &quot;OTU-331150:f__Lachnospiraceae&quot; ## [34] &quot;OTU-190188:f__Lachnospiraceae&quot; ## [35] &quot;OTU-185937:f__Lachnospiraceae&quot; ## [36] &quot;OTU-195120:f__Lachnospiraceae&quot; ## [37] &quot;OTU-212481:f__Lachnospiraceae&quot; ## [38] &quot;OTU-531888:f__Lachnospiraceae&quot; ## [39] &quot;OTU-192127:f__Lachnospiraceae&quot; ## [40] &quot;OTU-192515:Ruminococcus&quot; ## [41] &quot;OTU-178742:f__Ruminococcaceae&quot; ## [42] &quot;OTU-367176:Oscillospira&quot; ## [43] &quot;OTU-199422:Oscillospira&quot; ## [44] &quot;OTU-196553:Oscillospira&quot; ## [45] &quot;OTU-184511:Faecalibacterium&quot; ## [46] &quot;OTU-183157:Faecalibacterium&quot; ## [47] &quot;OTU-185244:Faecalibacterium&quot; ## [48] &quot;OTU-174846:Faecalibacterium&quot; ## [49] &quot;OTU-184000:Faecalibacterium&quot; ## [50] &quot;OTU-365717:Faecalibacterium&quot; ## [51] &quot;OTU-194626:f__Ruminococcaceae&quot; ## [52] &quot;OTU-186723:f__Ruminococcaceae&quot; ## [53] &quot;OTU-183048:f__Ruminococcaceae&quot; ## [54] &quot;OTU-42372:[Eubacterium]&quot; ## [55] &quot;OTU-191718:f__Erysipelotrichaceae&quot; ## [56] &quot;OTU-592616:f__Erysipelotrichaceae&quot; ## [57] &quot;OTU-357930:Dialister&quot; ## [58] &quot;OTU-4354173:Veillonella&quot; ## [59] &quot;OTU-190902:[Ruminococcus]&quot; ## [60] &quot;OTU-179408:[Ruminococcus]&quot; ## [61] &quot;OTU-189403:[Ruminococcus]&quot; ## [62] &quot;OTU-182506:[Ruminococcus]&quot; ## [63] &quot;OTU-196370:[Ruminococcus]&quot; ## [64] &quot;OTU-186652:Dorea&quot; ## [65] &quot;OTU-179905:f__Lachnospiraceae&quot; ## [66] &quot;OTU-183865:f__Lachnospiraceae&quot; ## [67] &quot;OTU-177237:Roseburia&quot; ## [68] &quot;OTU-195207:Roseburia&quot; ## [69] &quot;OTU-177515:Roseburia&quot; ## [70] &quot;OTU-194177:f__Lachnospiraceae&quot; ## [71] &quot;OTU-186263:f__Lachnospiraceae&quot; ## [72] &quot;OTU-198930:f__Lachnospiraceae&quot; ## [73] &quot;OTU-180312:f__Lachnospiraceae&quot; ## [74] &quot;OTU-531675:Blautia&quot; ## [75] &quot;OTU-183903:Blautia&quot; ## [76] &quot;OTU-198646:Blautia&quot; ## [77] &quot;OTU-181756:Blautia&quot; ## [78] &quot;OTU-194615:Blautia&quot; ## [79] &quot;OTU-192153:f__Lachnospiraceae&quot; ## [80] &quot;OTU-183969:f__Lachnospiraceae&quot; ## [81] &quot;OTU-573110:f__Lachnospiraceae&quot; 7.3.3 Good reads for ecological networks Using network analysis to explore co-occurrence patterns in soil microbial communities Microbial Co-occurrence Relationships in the Human Microbiome Correlation detection strategies in microbial data sets vary widely in sensitivity and precision sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 7 x64 (build 7601) Service Pack 1 ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Dutch_Netherlands.1252 LC_CTYPE=Dutch_Netherlands.1252 ## [3] LC_MONETARY=Dutch_Netherlands.1252 LC_NUMERIC=C ## [5] LC_TIME=Dutch_Netherlands.1252 ## ## attached base packages: ## [1] methods stats graphics grDevices utils datasets base ## ## other attached packages: ## [1] scales_0.5.0 sna_2.4 statnet.common_4.0.0 ## [4] bindrcpp_0.2.2 igraph_1.2.1 ggnet_0.1.0 ## [7] intergraph_2.0-2 network_1.13.0.1 SpiecEasi_0.1.4 ## [10] dplyr_0.7.4 ggpubr_0.1.6 magrittr_1.5 ## [13] RColorBrewer_1.1-2 microbiome_1.0.2 ggplot2_2.2.1 ## [16] phyloseq_1.23.1 ## ## loaded via a namespace (and not attached): ## [1] Biobase_2.38.0 viridis_0.5.1 ## [3] tidyr_0.8.0 VGAM_1.0-5 ## [5] jsonlite_1.5 viridisLite_0.3.0 ## [7] splines_3.4.4 foreach_1.4.4 ## [9] assertthat_0.2.0 stats4_3.4.4 ## [11] yaml_2.1.18 ggrepel_0.7.0 ## [13] pillar_1.2.2 backports_1.1.2 ## [15] lattice_0.20-35 glue_1.2.0 ## [17] digest_0.6.15 XVector_0.18.0 ## [19] colorspace_1.3-2 htmltools_0.3.6 ## [21] Matrix_1.2-14 plyr_1.8.4 ## [23] microbiomeutilities_0.99.0 pkgconfig_2.0.1 ## [25] pheatmap_1.0.8 bookdown_0.7 ## [27] zlibbioc_1.24.0 purrr_0.2.4 ## [29] huge_1.2.7 tibble_1.4.2 ## [31] mgcv_1.8-23 IRanges_2.12.0 ## [33] BiocGenerics_0.24.0 lazyeval_0.2.1 ## [35] survival_2.42-3 evaluate_0.10.1 ## [37] nlme_3.1-137 MASS_7.3-49 ## [39] vegan_2.5-1 tools_3.4.4 ## [41] data.table_1.10.4-3 formatR_1.5 ## [43] stringr_1.3.0 S4Vectors_0.16.0 ## [45] munsell_0.4.3 cluster_2.0.7-1 ## [47] Biostrings_2.46.0 ade4_1.7-11 ## [49] compiler_3.4.4 rlang_0.2.0 ## [51] rhdf5_2.22.0 grid_3.4.4 ## [53] iterators_1.0.9 biomformat_1.7.0 ## [55] rmarkdown_1.9 gtable_0.2.0 ## [57] codetools_0.2-15 multtest_2.34.0 ## [59] reshape2_1.4.3 R6_2.2.2 ## [61] gridExtra_2.3 knitr_1.20 ## [63] bindr_0.1.1 rprojroot_1.3-2 ## [65] permute_0.9-4 ape_5.1 ## [67] stringi_1.1.7 parallel_3.4.4 ## [69] Rcpp_0.12.16 tidyselect_0.2.4 ## [71] xfun_0.1 "]
]
